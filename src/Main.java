import java.time.LocalDate;


public class Main {
    public static void main(String[] args) {
        //---Задача 1---
        checkLeapYear(1960);
        //---Задача 2---
        checkOS(0, LocalDate.now().getYear());
        //---Задача 3---
        calculationDeliveryDistance(80);
        //---Доп задача---
        printAvgValueCost();


    }

    public static void checkLeapYear(int year) {
        System.out.println("Задача 1");
        /*
        Реализуйте метод, который получает в качестве параметра год, а затем проверяет, является ли он високосным, и выводит результат в консоль.
        Теперь проверку нужно обернуть в метод и использовать год, который приходит в виде параметра.
        Результат программы выведите в консоль. Если год високосный, то должно быть выведено “*номер года —* високосный год”.
        Если год не високосный, то, соответственно: “*номер года —* не **високосный год”.
         */
        if ((year % 4 == 0) && (year % 100 != 0) || (year % 400 == 0)) {
            System.out.println(year + " год является високосным");
        } else {
            System.out.println(year + " год не является високосным");
        }
    }

    public static void checkOS(int clientOS, int clientDeviceYear) {
        System.out.println("Задача 2");
        /*
        Напишите метод, куда подаются два параметра: тип операционной системы (ОС) (0 — iOS или 1 — Android) и год выпуска устройства.
        Если устройство старше текущего года, предложите ему установить lite-версию (облегченную версию).
        Текущий год можно получить таким способом:
        int currentYear = LocalDate.now().getYear();
        Или самим задать значение вручную, введя в переменную числовое значение.
        В результате программа должна выводить в консоль в зависимости от исходных данных, какую версию приложения (обычную или lite)
        и для какой ОС (Android или iOS) нужно установить пользователю.
         */
        if (clientOS == 1 && clientDeviceYear >= 2015) {
            System.out.println("Установите версию приложения для Android по ссылке");
        } else if (clientOS == 0 && clientDeviceYear >= 2015) {
            System.out.println("Установите версию приложения для iOS по ссылке");
        } else if (clientOS == 1 && clientDeviceYear < 2015) {
            System.out.println("Установите облегченную версию приложения для Android по ссылке");
        } else {
            System.out.println("Установите облегченную версию приложения для iOS по ссылке");
        }
    }

    public static void calculationDeliveryDistance(int deliveryDistance) {
        System.out.println("Задача 3");
        /*
        Возвращаемся к любимой многими задаче на расчет дней доставки банковской карты от банка.
        Наша задача — доработать код, а именно написать метод,
        который на вход принимает дистанцию и возвращает итоговое количество дней доставки.
         */
        int deliveryDays = 1;
                    if (deliveryDistance <= 20) {
                System.out.println("Потребуется дней: " + deliveryDays);
            } else if (deliveryDistance > 20) {
                        deliveryDays = deliveryDays + ((deliveryDistance - 20)/ 40 + 1);
                System.out.println("Потребуется дней: " + deliveryDays);
            }

        }
    public static double calculateCost (double [] arr){
        System.out.println("Доп задача");
        /*
    Снова вспоминаем домашнее задание по массивам. В нем была задача, которая требовала высчитать среднюю выплату за день.
    Был дан сгенерированный массив из 30 значений от 100 до 200 тысяч, для его генерации допускается использовать метод из
    прошлого домашнего задания.
    • Нам нужно понять, какую в среднем сумму наша компания тратила в течение данных 30 дней.
    • Нужно написать программу, которая посчитает среднее значение трат за месяц (то есть сумму всех трат за месяц поделить на количество дней),
    и вывести в консоль результат в формате: «Средняя сумма трат за месяц составила … рублей».
    == Важно помнить: подсчет среднего значения может иметь остаток (то есть быть не целым, а дробным числом).
    Нужно сгенерировать массив, подать его в наш метод, а внутри метода подсчитать сумму элементов и вычислить среднее значение,
    которое нужно вернуть из метода в виде результата.
    Сложность в том, что метод нужно не просто написать, но еще и декомпозировать.
    То есть для работы этого метода нужно будет создать еще методы (1 или более),
    которые его будут обслуживать и вычислять промежуточные результаты. Среднее значение нужно вычислять в дробном виде,
    так как результат должен быть точным.
         */

        double avgValueCost = 0;
        for (double i : arr) {
            avgValueCost += i;
        }
        avgValueCost = avgValueCost / arr.length;
        return avgValueCost;
        }
    public static double[] generateRandomArray() {
        java.util.Random random = new java.util.Random();
        double [] arr = new double[30];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(100_000) + 100_000;

        }
        return arr;
    }
    public static void printAvgValueCost(){
        double [] arr1 = generateRandomArray();
        System.out.printf("Средняя сумма трат за месяц составила: %.2f", calculateCost(arr1));
    }
    }
